# 참조자와 스마트 포인터의 차이
- 참조자: 데이터를 빌리기만 함.
- 스마트 포인터: 가리킨 데이터를 소유함.


# 스마트 포인터 구현
- 스마트 포인터는 구조체로 구현됨.
- 스마트 포인터는 `Deref`, `Drop` 트레이트를 구현함.
  -  `Deref`: 참조자처럼 동작하도록 하여 참조자, 스마트 포인터 둘다 함께 작동하는 코드를 작성하도록 도와줌.
  -  `Drop`:  스마트 포인터 인스턴스가 스코프 밖으로 벗어났을 때 실행되는 코드를 커스터마이징 할 수 있도록 함.


# 대표적인 스마트 포인터

## 값을 힙에 할당하기 위한 `Box<T>`

박스는 스택이 아니라 힙에 데이터를 저장할 수 있도록 해줌. 스택에 남는 것은 힙 데이터를 가리킨 포인터임.

박스가 쓰이는 사례
- 컴파일 타임에는 크기를 알 수 없는 타입이 있는데, 정확한 크기를 요구하는 컨텍스트 내에서 그 타입의 값을 사용하고 싶을 때
- 커다란 데이터를 가지고 소유권을 옮기고 싶지만 그렇게 했을 때 데이터가 복사되지 않을 것을 보장하고 싶을 때
- 어떤 값을 소유하고 이 값의 구체화된 타입보다는 특정 트레이트를 구현한 타입이라는 점만 신경쓰고 싶을 때

## 복수 소유권을 가능하게 하는 참조 카운팅 타입인 `Rc<T>`
- Reference Counting의 약자이고, 값이 계속 사용 중인지를 판단하는 스마트 포인터임.
- 특정 데이터에 대한 참조 갯수가 늘어날 수록 `Rc<T>` 내의 참조하는 count가 늘어나고, 스코프가 벗어날수록 참조하는 갯수가 감소함.

## 대여 규칙을 컴파일 타임 대신 런타임에 강제하는 타입인 `RefCell<T>`를 통해 접근 가능한 `Ref<T>`와 `RefMut<T>`
`Rc<T>`와는 다르게, `RefCell<T>` 타입은 가지고 있는 데이터에 대한 단일 소유권을 나타냅니다. 그렇다면, `Box<T>`와 같은 타입과 `RefCell<T>`의 다른 부분은 무엇일까요? 4장에서 배웠던 대여 규칙을 상기해 봅시다:

- 어떠한 경우이든 간에, 하나의 가변 참조자 혹은 여러 개의 불변 참조자 중 (둘 다가 아니고) 하나만 가질 수 있습니다.
- 참조자는 항상 유효해야 합니다.

참조자와 `Box<T>`를 이용할 때, 대여 규칙의 불변성은 <u><b>컴파일 타임</b></u>에 집행됩니다. `RefCell<T>`를 이용할 때, 이 불변성은 <u><b>런타임</b></u>에 집행됩니다. 참조자를 가지고서 이 규칙을 어기면 컴파일러 에러를 얻게 될 것입니다. `RefCell<T>`를 가지고서 여러분이 이 규칙을 어기면, 프로그램은 panic!을 일으키고 종료될 것입니다.

# `Box<T>`, `Rc<T>`, 혹은 `RefCell<T>`을 선택하는 이유
- `Rc<T>`는 동일한 데이터에 대해 복수 소유자를 가능하게 합니다; `Box<T>`와 `RefCell<T>`은 단일 소유자만 갖습니다.
- `Box<T>`는 컴파일 타임에 검사 되는 불변 혹은 가변 대여를 허용합니다; `Rc<T>`는 오직 컴파일 타임에 검사 되는 불변 대여만 허용합니다; `RefCell<T>`는 런타임에 검사되는 불변 혹은 가변 대여를 허용합니다.
- `RefCell<T>`이 런타임에 검사 되는 가변 대여를 허용하기 때문에, `RefCell<T>`이 불변일 때라도 `RefCell<T>` 내부의 값을 변경할 수 있습니다.